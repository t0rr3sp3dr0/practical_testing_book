Mutation Testing
================

## Overview

Mutation Testing propose the creation of variations of the software under test in order that these tests show that these variations are not correct, therefore by elimination it can be verified that the original program is correct, these checks are made based on execution of existing unit tests. With this in mind, we can consider mutation testing as a technique to help in the process of improving test cases, making them more efficient, as well as to improve or guarantee the quality of these test cases, note that the test technique of mutation testing is a white box test technique.

Mutation Testing works in the following way, the mutation operators are used on the original code making small changes on those in order to generate some variations called mutants, hence the name given to the technique. After the mutants have been generated, the tests originally used to test the code are performed on the generated mutants, if these mutants fail the test cases they will be considered ‘killed’ mutants, if any mutant does not fail it is considered a ‘survived’ mutant and this is an indication that the tests need to be reviewed/analyzed, making these tests more efficient after these analyzes and corrections.

Here is an example of a mutation in a python code:
```python
def summation(*values):
    total = 0
    for i in values:
        total+=i
    return total
```
The Assignment Operator Replacement (ASR) would replace `+=` with `-=` and produce the following mutant:
```python
def summation(*values):
    total = 0
    for i in values:
        total-=i
    return total
```
or other change can be the Constant Replacement (CRP) that would replace `total = 0` with `total = 1` and produce the following mutant:
```python
def summation(*values):
    total = 1
    for i in values:
        total+=i
    return total
```
When the mutants survive the tests, two situations can be considered, the first is when the test cases are not good enough, as they have not identified the changes in the mutants, and the second is the equivalence between the original program and the mutant called Equivalent Mutant, equivalent mutants are one of the major problems in using mutation tests.

For example, let's consider a particular code section of a program *pro*, and we're going to indicate a mutant for that program *mut*. In this case the *mut* is going to be an equivalent mutant if *mut* is syntactically different from *pro* but have the same behavior as *pro*.
```java
//Program pro
for (int i=0; i<10; i++){
    /* i value still the same */
}
```
```java
//Equivalent Mutant mut
for (int i=0; i!=10; i++){
    /* i value still the same */
}
```
The example above shows a mutant that was generated by the Relational Operator Replacement (ROR), which changes the operator  `<` for `!=`, if during the execution of the mutant the loop instruction does not change the value of `i`, in this case both, the program pro and your mutant mut, will produce the same output.

## Mutation Operators

Mutation operators are changes that are made to the original code in order to generate mutants, these changes can be made by modifying expressions by changing, adding or removing operators and/or statements. These operators can be arithmetic, relational, conditional, logical, assignment, among others.

### Examples of Operators Used

#### Structural mutation operators
 * AOD - Arithmetic Operator Deletion
 * AOR - Arithmetic Operator Replacement
 * AOI - Arithmetic Operator Insertion
 * COD - Conditional Operator Deletion
 * COR - Conditional Operator Replacement
 * COI - Conditional Operator Insertion
 * ASR - Assignment Operator Replacement
 * LOD - Logical Operator Deletion
 * LOR - Logical Operator Replacement
 * LOI - Logical Operator Insertion
 * BCR - Break Continue Replacement
 * CRP - Constant Replacement
 * LCR - Logical Connector Replacement
 * ROR - Relational Operator Replacement
 * SOR - Shift Operator Replacement

#### Object-Oriented mutation operators
 * EHD - Exception Handler Deletion
 * EXS - Exception Swallowing
 * IHD - Hiding Variable Deletion
 * IOD - Overriding Method Deletion
 * IOP - Overridden Method Calling Position Change
 * SCD - Super Calling Deletion
 * SCI - Super Calling Insertion

#### Python-related mutation operators
 * DDL - Decorator Deletion
 * SIR - Slice Index Remove

Some of this operators will be shown on 'Hands On: MutPy' section. 

## Pros and Cons

### Pros
 * Creation of effective test suites;
 * Verification of the suite's reliability;
 * Help in refactoring tests;

### Cons
 * The high computational cost;
 * The amount of human effort involved;

## Background

Good materials on Mutation testing can be found in the literature, some of which were used as the basis for the elaboration of this chapter, such as the survey published by Jia and Harman (2011){cite}`5487526`, Ma and Offutt (2005){cite}`ma2005description` and Dereziska and Halas (2014){cite}`6825653` publications that also talk about mutation operators, among other works such as those by Madeyski et al (2014){cite}`6613487`, Frankl et al (1997){cite}`frankl1997all`, and Papadakis et al (2019){cite}`papadakis2019chapter`.

## Hands On: MutPy
 
> [MutPy](https://pypi.org/project/MutPy/) is a mutation testing tool for Python 3.3+ source code. MutPy supports standard unittest module, generates YAML/HTML reports and has colorful output. It applies mutation on AST level. You could boost your mutation testing process with high order mutations (HOM) and code coverage analysis.

For a more constructive practice, let's hands on at Colab:

<a href="https://colab.research.google.com/github/damorimRG/practical_testing_book/blob/master/testadequacy/mutation.ipynb" target="_blank"> 
    <img alt="Open In Colab" src="https://colab.research.google.com/assets/colab-badge.svg"></a>

## References

```{bibliography} ../zreferences.bib 
    :style: plain 
    :filter: docname in docnames
```